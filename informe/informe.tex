\documentclass[a4paper,oneside]{report}
\usepackage[spanish]{babel}
\usepackage[latin1]{inputenc}
\usepackage{fullpage}
\usepackage{listings}
\usepackage{gmverb}
\usepackage[colorlinks=true,urlcolor=black,linkcolor=black]{hyperref}%
\usepackage{listings}

\setlength{\parskip}{1ex plus 0.5ex minus 0.2ex}

\lstset{language=,keywordstyle=\ttfamily,stringstyle=\ttfamily}
\lstset{breaklines}

\title{Compiladores e Intérpretes\\Informe del Segundo Proyecto}

\author{Diego Marcovecchio (LU: 83815)\and Leonardo Molas (LU: 82498)}

\date{26 de Octubre de 2010}

\begin{document}
\lstset{frame=single}	
\maketitle
		
\tableofcontents

\chapter*{Introducción}
\section*{Descripción}

Este proyecto consiste en la implementación de un intérprete de un subconjunto del lenguaje funcional ML, que devolverá como salida el tipo de las expresiones ingresadas. Para esto se utilizaron las herramientas automáticas JLex y CUP aplicadas en el entorno del lenguaje de programación Java, que se encargan de generar un parser ascendente que reconoce las cadenas ingresadas y aplica las reglas semánticas convenientemente definidas.

\section*{Archivos entregados}
El proyecto está estructurado en tres carpetas:
\begin{itemize}
	\item /bin: incluye un jar ejecutable con el intérprete, y diversos archivos de test.
	\item /doc: incluye el pdf con la documentación del proyecto.
	\item /src: incluye todos los archivos necesarios para compilar el proyecto:
		\begin{itemize}
			\item /JLex: carpeta que contiene todos los archivos propios de la herramienta JLex.
			\item /java\_cup: carpeta que contiene todos los archivos propios de la herramienta CUP.
			\item Attrs.java: clase auxiliar definida para guardar los datos de los no-terminales en la gramática; a grandes rasgos, para cada no-terminal se recuerda el tipo de la expresión que sintetiza, y una lista de \emph{related-ids}; cada identificador que apunta a este objeto en la tabla de símbolos es indicado a su vez en esta lista, lo que permite, por ejemplo, detectar cuándo dos identificadores son el mismo tipo de politipo, o cambiar el tipo de un grupo de identificadores de "`politipo"' a "`real"'.
			\item lex.lex: archivo que define los patrones de los tokens devueltos por el analizador léxico generado automáticamente con la herramienta JLex.
			\item cup.cup: archivo que define la gramática y las reglas semánticas utilizadas por el parser generado automáticamente con la herramienta CUP.
			\item bat.bat: script de consola para Windows que se encarga de eliminar archivos anteriores, generar el analizador léxico, el parser, y recompilar el intérprete para ser ejecutado desde consola.
			\item sh.sh: script de consola para sistemas Linux/Unix, que realiza las mismas funciones que el bat.
		\end{itemize}
\end{itemize}

\chapter{Modo de uso}
\$ java -jar MLOR \emph{[inputFile]},

donde \emph{inputFile} es un archivo con código ml que puede ingresarse opcionalmente.  Si bien el programa no fue pensado específicamente para ser utilizado con archivos de entrada, se incluyó la opción para facilitar la corrección del intérprete por parte de la cátedra. Si efectivamente se especifica un archivo, para cada una de las expresiones que contenga, el intérprete mostrará el tipo como la cátedra solicitó. En caso de que {\bf no} se especifique ningún archivo, el intérprete mostrará un prompt para leer expresiones y funciones por pantalla, y mostrará el tipo de cada una de ellas. MLOR está pensado para ser utilizado con el prompt, por lo que al ingresar los casos de prueba directamente desde un archivo el formato de salida puede no ser el ideal.

Para realizar una asignación se utiliza val \emph{X} = \emph{Y};, siendo \emph{X} el nombre de la variable que recibirá el resultado, e \emph{Y} la expresión que se asignará a \emph{X}. En caso de que únicamente se ingrese una expresión, ésta se ligará por defecto a la variable \emph{it}.

Ejemplos:
\begin{lstlisting}[frame=single]
MLOR> val x = 5;
val x: int;
\end{lstlisting}
En este caso, el valor entero 5 se liga a la variable global \emph{x}.


\begin{lstlisting}
MLOR> 11.11
val it: real;
\end{lstlisting}
En este caso, el real mostrado se liga implícitamente a la variable glogal \emph{it}.

Para declarar una función, se ingresa el prefijo \emph{fun} en el intérprete seguido de los parámetros correspondientes y su expresión:

\begin{lstlisting}
MLOR> fun f x = x + 5;
val f: int -> int = fn;
MLOR> fun g x y = (f x > 10) orelse (x>y);
val g: int -> int -> boolean = fn;
\end{lstlisting}
En este ejemplo se declaran dos funciones: \emph{f}, con parámetro \emph{x}, y \emph{g}, con parámetros \emph{x} e \emph{y}, que a su vez utiliza la función f.

Tanto las variables globales como los identificadores de las funciones son recordados internamente en el parser en una tabla de símbolos (implementada con una tabla hash de Java). En dicha tabla se mantiene como llave el identificador, y la entrada de la tabla contiene un objeto que es instancia de la clase Attrs; a medida que los identificadores se relacionan en la expresión, pueden apuntar a la misma instancia de Attrs; por ejemplo, en una expresión como la del último ejemplo, \emph{x} e \emph{y} apuntarán a la misma instancia de Attrs. Se detalla con mayor profundidad cómo se decide el tipo de las expresiones en la sección {\bf Analizador Semántico}.

\section{Requerimientos}

Dada la tecnología utilizada para realizar el intérprete, será necesario contar con la máquina virtual de Java (oficialmente fue probado para la versión 1.6) para poder correr el archivo ejecutable \emph{MLOR}. En caso de desear compilar manualmente el intérprete en Windows, las variables \emph{class} y \emph{classpath} deben estar correctamente seteadas.

\section{Formato de salida}

El formato de salida utilizado es igual al del lenguaje original ML: todas las expresiones poseen un tipo determinado, y todas las funciones poseen un dominio y un rango, que se representan mediante la notación Dominio -\textgreater Rango. Las expresiones ingresadas en el intérprete y pueden ser de tipo \emph{int}, \emph{real}, \emph{boolean}, \emph{string}, \emph{list} (que a su vez tiene un tipo asociado) y \emph{tuple} (que tiene un tipo asociado por cada uno de sus elementos). En el caso particular de las funciones, se consideran dos tipos especiales además de los mencionados: el politipo, y el politipo con igualdad. Dado que puede haber muchas instancias de politipos diferentes, los primeros se notan con un apóstrofe seguido del identificador del politipo, mientras que los segundos son precedidos por \emph{dos} apóstrofes.


\begin{lstlisting}
MLOR> 5;
val it: int
\end{lstlisting}
Ejemplo de una expresión entera ligada implícitamente a \emph{it}.


\begin{lstlisting}
MLOR> val x = 5;
val x: int;
\end{lstlisting}
La misma expresión entera, ligada explícitamente a \emph{x}.


\begin{lstlisting}
MLOR> val y = (1,2.0);
val y: (int * real);
\end{lstlisting}
Una tupla de tipo (int * real) ligada explícitamente a \emph{y}.


\begin{lstlisting}
MLOR> fun f x = 5;
val f: 'a -> int = fn;
\end{lstlisting}
Una función f que recibe un parámetro de cualquier tipo y  devuelve el número entero 5.

\begin{lstlisting}
MLOR> fun g x y = x=y;
val f: ''a -> ''a -> boolean = fn;
\end{lstlisting}
Una función g que recibe dos parámetros del mismo tipo \emph{que soporte igualdad}, los compara, e indica si son iguales o no.

\begin{lstlisting}
MLOR> fun h x y = (x,y);
val h: 'a -> 'b -> ('a * 'b) = fn;
\end{lstlisting}
Una función h que recibe dos parámetros de cualquier tipo \emph{(no necesariamente igual)}, y devuelve una tupla con estos dos elementos.


\chapter{Analizador léxico}
\section{Tokens}
El Analizador Léxico reconoce los tokens especificados en la tabla \ref{tab:tokens}.
\begin{table}[H]

\begin{tabular}{|l|l|}
\hline
\textbf{Token}			& \textbf{Expresión Regular} \\ \hline
PUNTO			 					& {\ttfamily .} \\ \hline
PTOCOMA							& {\ttfamily ;} \\ \hline
IGUAL								& {\ttfamily =} \\ \hline
COMA      					& {\ttfamily ,} \\ \hline
DISTINTO	 					& {\ttfamily \textless \textgreater \ } \\ \hline
OPREL			 					& {\ttfamily <|>|<=|>=} \\ \hline
CONS			 					& {\ttfamily ::} \\ \hline
OPADD 							& {\ttfamily +|-} \\ \hline
ORELSE						 	& {\ttfamily (o|O)(r|R)(e|E)(l|L)(s|S)(e|E)} \\ \hline
CONCAT 							& {\ttfamily \^ \ } \\ \hline
MUL				 					& {\ttfamily *} \\ \hline
DIVREAL						 	& {\ttfamily /} \\ \hline
DIVINT							& {\ttfamily (d|D)(i|I)(v|V) } \\ \hline
MOD								 	& {\ttfamily (m|M)(o|O)(d|D)} \\ \hline
ANDALSO						 	& {\ttfamily (a|A)(n|N)(d|D)(a|A)(l|L)(s|S)(o|O)} \\ \hline
NOT						 			& {\ttfamily (n|N)(o|O)(t|T)} \\ \hline
MINUS					 			& {\ttfamily \~ \ } \\ \hline
PARABRE 						& {\ttfamily (} \\ \hline
PARCIERRA						& {\ttfamily )} \\ \hline
CORABRE							& {\ttfamily [} \\ \hline
CORCIERRA						& {\ttfamily ]} \\ \hline
NIL			 						& {\ttfamily (n|N)(i|I)(l|L)} \\ \hline
FUN				 					& {\ttfamily (f|F)(u|U)(n|N)} \\ \hline
VAL		 							& {\ttfamily (v|V)(a|A)(l|L)} \\ \hline
REAL 								& {\ttfamily [0-9]+.[0-9]+} \\ \hline
INT 								& {\ttfamily [0-9]+} \\ \hline
STRING							& {\ttfamily ``[\^\ `` \^\ \textbackslash n]*'' } \\ \hline
ID		 							& {\ttfamily [a-z][a-z0-9]*} \\ \hline
\end{tabular}
\label{tab:tokens}
\caption{Tokens}
\end{table}

\section{Palabras reservadas}
El analizador léxico de MLOR mantiene algunas palabras reservadas que no puede ser redefinidas por el usuario para nombrar una función o un valor; dichas palabras son los operadores lógicos \emph{orelse} y \emph{andalso}, los operadores aritméticos \emph{div} y \emph{mod}, el operador unario \emph{not}, el indicador de lista vacía \emph{nil}, el prefijo de las funciones \emph{fun}, y el de los valores, \emph{val}.

Nótese que \emph{true} y \emph{false} no son palabras reservadas, sino variables booleanas insertadas por defecto en la tabla de símbolos, por lo que podrían redefinirse al valor que el usuario del intérprete desee.


\chapter{Lenguaje}
\section{Alfabeto de entrada}

La gramática original fue ligeramente modificada para eliminar algunas ambiguedades (por ejemplo, el hecho de que una derivación de una tupla de un único elemento y una expresión parentizada podían resultar iguales). Además, los operadores de las expresiones fueron separados utilizando las reglas de precedencia definidas en ML (y mencionadas adecuadamente en el enunciado entregado para la realización del intérprete). La gramática resultante, utilizada por CUP para la generación del parser, es:

\begin{verbatim}

<Programa> ::= <Lista_sentencias> PUNTO

<Lista_sentencias> ::= <Lista_sentencias> <Sentencia> PTOCOMA | <Sentencia> PTOCOMA

<Sentencia> ::= VAL ID = <Exp_Rel> | <Exp_Rel> | FUN <MatchingFunc>	

<MatchingFunc> ::= ID ID <CurryingList> | ID <TuplePattern> IGUAL <Exp_Rel>

<CurryingList> ::= ID <CurryingList> | IGUAL <Exp_Rel>

<TuplePattern> ::= PARABRE <TuplePattern2> PARCIERRA

<TuplePattern2> ::= <TuplePattern2> COMA ID  | ID

<Exp_Rel>  	::= 	<Exp_Rel> OPREL <Exp_cons> | <Exp_Rel> DISTINTO <Exp_cons> | <Exp_Rel> IGUAL <Exp_cons> | <Exp_cons>

<Exp_cons> 	::=	<Exp_add> CONS <Exp_cons>| <Exp_add>

<Exp_add>  	::=	<Exp_add> OPADD <Exp_mul> | <Exp_add> ORELSE <Exp_mul> | <Exp_add> CONCAT <Exp_mul> | <Exp_mul>

<Exp_mul>  	::=	<Exp_mul> MUL <Exp_un> | <Exp_mul> DIVREAL <Exp_un> | <Exp_mul> DIVINT <Exp_un> | <Exp_mul> MOD <Exp_un> | <Exp_mul> ANDALSO <Exp_un> | <Exp_un>

<Exp_un>   	::=	NOT <Exp_fun> | MINUS<Exp_fun> | <Exp_fun>

<Exp_fun>  	::= 	<Exp_fun> <Exp_atom> | <Exp_atom>

<Exp_atom>	::=	INT | REAL | STRING | ID | NIL | PARABRE <Exp_Rel> PARCIERRA | <Tuple> | <List>

<Tuple> 	::= PARABRE <Exp_Rel> COMA <Tuple2> PARCIERRA

<Tuple2> 	::= <Tuple2> COMA <Exp_Rel> | <Exp_Rel>

<List> 		::= CORABRE <List2> CORCIERRA

<List2> 	::= <List2> COMA <Exp_Rel> | <Exp_Rel>
\end{verbatim}

\section{Errores detectados}

INDICAR ERRORES DETECTADOS.

\end{document}
