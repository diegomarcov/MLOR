import java_cup.runtime.*;
import java.io.*;
import java.util.*;


action code
{:
	Hashtable st,localST;
	int politipoActual=0;
	
	
	//lo cambie para que devuelva el string, porque va a ser mas facil cuando apliquemos recursivamente
	private String obtenerStringTipo(Attrs tipo){
	ArrayList<Attrs> list;
	String aux;
		System.out.println("entre a obtenerStringTipo");
		if (tipo.getType().equals("list")){
			System.out.println("estoy en lista");
			return obtenerStringTipo(tipo.getListType())+" list";
		}
		else if (tipo.getType().equals("tuple")){
			System.out.println("estoy en tupla");
			list = tipo.getTupleTypes();
			aux = "(";
			for (int i=0;i<list.size();i++){
				aux+=obtenerStringTipo(list.get(i));
				if (i!=list.size()-1){
					aux+=" * ";
				}
			}			
			aux+=")";
			return aux;
		}
		else if (tipo.getType().equals("fun")){
			System.out.println("estoy en fun");
			return (obtenerStringTipo(tipo.getDomain()) + " -> " + obtenerStringTipo(tipo.getRange()));
		}
		else{
			System.out.println("estoy en tipo simple");
			return tipo.getType();
		}
	}	
	
	private boolean esTipoSimple(Attrs t1){
		return (t1.equals("int") || t1.equals("real") || t1.equals("boolean") || t1.equals("string"));
	}
	
	private void imprimirTipo(Attrs tipo){
		System.out.print(obtenerStringTipo(tipo));
	}
	
	private String obtenerTipo(String id) throws Exception{
		Attrs t;
		if (localST != null){
			t = (Attrs) localST.get(id);
			if(t != null){
				return (t.getType());
			}else{				
				t = (Attrs) st.get(id);
				if(t != null){
					return (t.getType());
				}else{
					throw new Exception("Undeclared identifier!");
				}
			}
		}else{
			t = (Attrs) st.get(id);
			if(t != null){
				return (t.getType());
			}else{
				throw new Exception("Undeclared identifier!");
			}		
		}
		
	}
	
	private boolean putLocalID(String id){
	
		if (localST.get(id)==null){
			Attrs aux =crearPolitipo();
			localST.put(id,aux);
			System.out.println("insertando " + id + " a la tabla local con " + aux.getType());
			return true;
		}
		else{
			return false;
		}
	}
	
	private Attrs crearPolitipo(){
		Attrs aux = new Attrs("politipo");
		aux.setPolytype(politipoActual);
		politipoActual++;
		return aux;
	}
	
	private void clonarTipos(Attrs type1,Attrs type2){
		type1.setListType(type2.getListType());
		type1.setType(type2.getType());
		type1.setPolytype(type2.getPolytype());
		type1.setTupleTypes(type2.getTupleTypes());
		type1.setDomain(type2.getDomain());
		type1.setRange(type2.getRange());
	}
	
	//devuelve el tipo más específico, y CAMBIA los valores de los tipos para que sean iguales. 
	//de no haber compatibilidad, devuelve null
	private Attrs tipoMasEspecifico(Attrs type1, Attrs type2){
		String t1,t2;
		ArrayList listT1,listT2,result;
		Attrs tResult;
		t1 = type1.getType();
		t2 = type2.getType();
		System.out.println(""+t1.equals("int")+t2.equals("int")+t1.equals(t2));
		if ((esTipoSimple(t1)) && (esTipoSimple(t2)) && t1.equals(t2)){
		//si ambos son tipos simples o iguales, todo OK
			return type1;
		}
		else{
			if (t1.equals(t2)){ //los tipo de t1 y 2 son iguales, pero no son tipos basicos
				if (t1.equals("tuple")){
					//ambos son tuplas
					if (type1.getTupleLenght()==type2.getTupleLenght()){
					//ambos son tuplas de la misma longitud
						listT1 = type1.getTupleTypes();
						listT2 = type2.getTupleTypes();
						result = new ArrayList();
						for (int i=0;i<listT1.size();i++){
							tResult = tipoMasEspecifico((Attrs) listT1.get(i),(Attrs) listT2.get(i));
							if (tResult!=null)
								result.add(tResult);
							else
								return null;
						}
						type2.setTupleTypes(result);
						type1.setTupleTypes(result);
						return type1;
					}
					//ambos son tuplas, pero las longitudes no coindicen
					return null;
				}
				else if (t1.equals("list")){
					//ambos son listas
					tResult = tipoMasEspecifico(type1.getListType(),type2.getListType());
					if (tResult!=null){
						type1.setListType(tResult);
						type2.setListType(tResult);
						return type1;
					}
					else
						return null;
				}
				//ambos son el mismo tipo de politipo
				else if (t1.equals("politipo") || t1.equals("politipo con igualdad") || t1.equals("politipo numerico")){
					//indicamos que, si uno es 'a y el otro es 'b, ahora ambos pasan a ser 'a
					type2.setPolytype(type1.getPolytype()); //aca tenemos que mergear las listas, hacer que todos los ids de las listas apunten al mismo tipo,  y devolver uno de los dos
					return type1;
				}
				else
					return null;
			}else{ //los tipos de t1 y 2 son distintos
				if (t1.equals("politipo") || t1.equals("politipo con igualdad")){
					//si uno de los tipos es un politipo, lo clonamos al otro
					clonarTipos(type1,type2);
					return type2;
				}
				else if (t2.equals("politipo") || t2.equals("politipo con igualdad")){
					//si uno de los tipos es un politipo, lo clonamos al otro
					clonarTipos(type2,type1);
					return type1;
				}
				else if (t1.equals("politipo numerico" )){
					//si uno es un politipo numerico, y el otro es int o real, asignamos el politipo
					if (t2.equals("int") || t2.equals("real")){
						type1.setType(t2);
						return type2;
					}
					else 
						return null;
				}
				else if (t2.equals("politipo numerico" )){
					//si uno es un politipo numerico, y el otro es int o real, asignamos el politipo
					if (t1.equals("int") || t1.equals("real")){
						type2.setType(t1);
						return type1;
					}
					else 
						return null;
				}
				else // si no es ningun politipo, y son distintos, se rompio
					return null;
			}
		}
		
	}
:}

parser code 
{:
	public static void main(String args[])
	{
		try
		{
			new parser(new Yylex(System.in)).parse();
		}
		catch (Exception e)
		{
			System.err.println(e.getMessage());
		}
	}
	
	
:}

terminal Token PUNTO, PTOCOMA, IGUAL, COMA, OPREL, CONS, OPADD, ORELSE, CONCAT, MUL, DIVREAL, DIVINT, MOD, ANDALSO, NOT, MINUS, PARABRE, PARCIERRA, CORABRE, CORCIERRA, NIL, FUN, VAL, ID, INT, REAL, STRING;

non terminal Programa, Lista_sentencias;

non terminal Attrs Sentencia, MatchingFunc, CurryingList, TuplePattern, TuplePattern2, Exp_Rel, Exp_cons, Exp_add, Exp_mul, Exp_un, Exp_fun, Exp_atom, Tuple, Tuple2, List, List2;

Programa ::= 	{: 	
					st=new Hashtable(); 
					System.out.println("Succesfully created symbol table!"); 
				:} 
				Lista_sentencias 	{: System.out.println("Succesfully parsed!"); :} 
				PUNTO	{: System.out.println("PUNTO found!"); :} 
				;

Lista_sentencias ::= 	Lista_sentencias 
						{: System.out.println("Leyendo otra sentencia"); :}
						Sentencia 
						PTOCOMA 
						| 
						{: System.out.println("Entrando a leer la primer sentencia"); :}
						Sentencia 
						{: System.out.println("; found!"); :}
						PTOCOMA	
						;

Sentencia ::= 	VAL {: System.out.println("VAL found!");:}
				ID:id	{: System.out.println("ID found!"); :}
				IGUAL 	{: System.out.println("= found!"); :}
				Exp_Rel:exp {: System.out.println("Rest of Exp_Rel found!"); 
						st.put(id.getLexeme(),exp);:}
				| 
				Exp_Rel:exp
				{: 	st.put("it",exp);
					System.out.print("val it: ");
					imprimirTipo(exp);
				:}
				| 
				FUN 
				{: localST = new Hashtable(); :}
				MatchingFunc
				{: localST = null; :}
				;

MatchingFunc ::= ID:f ID:param {:System.out.println(""+putLocalID(param.getLexeme()));:} //pone el parametro con un politipo
				CurryingList:list  
					{:Attrs aux = new Attrs("fun",(Attrs)localST.get(param.getLexeme()), list);
					  st.put(f.getLexeme(),aux); 
					  System.out.print(f.getLexeme()+": ");
					  imprimirTipo(aux);
					  System.out.println(" = fn;");
					:}
				|  
				ID:f
				TuplePattern:tuple
				IGUAL
				Exp_Rel:exp {:st.put(f.getLexeme(), new Attrs("fun",tuple,exp));:};

CurryingList ::= ID:id {:putLocalID(id.getLexeme());:}
				CurryingList:list {:RESULT = new Attrs("fun",(Attrs)localST.get(id.getLexeme()),list);:}
				| IGUAL Exp_Rel:exp {:RESULT = exp;:};

TuplePattern ::= PARABRE TuplePattern2:tp PARCIERRA{:RESULT = tp; :};

TuplePattern2 ::= TuplePattern2 COMA ID:id {:putLocalID(id.getLexeme());:}  
					| 
					ID:id {:putLocalID(id.getLexeme());:};

Exp_Rel  	::= Exp_Rel OPREL Exp_cons| Exp_Rel IGUAL Exp_cons | Exp_cons:e {: RESULT = e; :};
				
Exp_cons 	::=	Exp_add CONS Exp_cons | Exp_add:e {: RESULT = e; :};

Exp_add  	::=	Exp_add OPADD Exp_mul | 
				Exp_add ORELSE Exp_mul | Exp_add CONCAT Exp_mul | Exp_mul:e {: RESULT = e; :};

Exp_mul  	::=	Exp_mul MUL Exp_un | Exp_mul DIVREAL Exp_un | Exp_mul DIVINT Exp_un |
				Exp_mul MOD Exp_un | Exp_mul ANDALSO Exp_un | Exp_un:e {: RESULT = e; :};

Exp_un   	::=	NOT Exp_fun:fun 
				{: 	if (tipoMasEspecifico(fun, new Attrs("boolean"))!=null){
						RESULT = fun;
					}else{
						throw new Exception("Not a valid function!");
					}
				:}
				| 
				MINUS Exp_fun:fun 
				{: 	
					Attrs t = tipoMasEspecifico(fun, new Attrs("politipo numerico"));
					if (t != null){
						RESULT = t;
					}else{
						throw new Exception("Not a valid function!");
					}
				:}
				| 
				Exp_fun:e {: RESULT = e; :};

Exp_fun  	::= Exp_fun:f Exp_atom:atom
				{: 	if (f.getType().equals("fun")){
						if (tipoMasEspecifico(f.getDomain(), atom)!=null){
						// hay que checkear para cambiar el tipo de atom _O_ las variables de f!
							RESULT = f.getRange();
						}else{
							throw new Exception("Invalid parameter type!");
						}
					}else{
						throw new Exception("Not a valid function!");
					}
				:}
				| 
				Exp_atom:atom {: RESULT = atom; :};

Exp_atom	::=	INT {: RESULT = new Attrs("int"); :}
				| 
				REAL {: RESULT = new Attrs("real") ;:} 
				| 
				STRING {: RESULT = new Attrs("string") ;:}
				| 
				ID:id {:Attrs aux = new Attrs(obtenerTipo(id.getLexeme()));
						if (aux!=null){
							if (!esTipoSimple(aux)){
								aux.agregarID(id.getLexeme());
							}
							RESULT = aux;
						}
						else
							throw new Exception("Undeclared identifier (" + id.getLexeme() +")");
					  :}
				| 
				NIL {: RESULT = new Attrs("list") ;:}
				| 
				PARABRE 
				Exp_Rel:e {: e.deleteInvolvedIDs(); // se supone que los tipos de los id estan resueltos
							 RESULT = e; :}
				PARCIERRA 
				| 
				Tuple:t {:RESULT = t; :} 
				| 
				List:l {:RESULT = l; :};

Tuple 	::= PARABRE Exp_Rel:e COMA Tuple2:t2 PARCIERRA {:t2.addTupleTypeBegin(e);
														RESULT = t2; :};

Tuple2 	::= Tuple2:t COMA Exp_Rel:e 
			{:
				t.addTupleTypeFinal(e);
				RESULT = t;
			:}
			| 
			Exp_Rel:e {: 	Attrs t = new Attrs("tuple", new ArrayList());
							t.addTupleTypeBegin(e);
							RESULT = t;
			:};

List 		::= CORABRE List2:l CORCIERRA {:RESULT = l;:};

List2 	::= List2:list COMA Exp_Rel:exp {:Attrs t = tipoMasEspecifico(list.getListType(),exp);
										  if (t!=null)
											RESULT = list;
										  else
											throw new Exception("The list has elements of different types.");
										  :}
			| 
			Exp_Rel:exp {:RESULT = new Attrs("list",exp);:};